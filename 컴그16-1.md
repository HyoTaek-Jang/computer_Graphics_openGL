쉐도우매핑의 장점
여러 라이트가 있어도 다 만들면 어떤 라이트에서 보이고 어떤 라이트에서 안보이는지 알 수 있다.

offscreen buffer -> 화면 밖에서 프레임버퍼. 라이트가 어떻게 비치는지 알 수 있게. frame buffer obj 여기다가 댑쓰를 랜더링함 그리고 실제 랜더링할때 이걸 들고와서 비교하면서 랜더링함.
랜더링을 두번이상해서 멀티패쓰 랜더링이라고 함.

쉐도우매핑에선 그림을 그리지 않음. 데이터가 일단 없는상태로 진행하고 나중에 채우는거로. GL_32F -> 정밀하게 하기 위해서 float로.

바인드 풀어주는거 잊지말기...!

각각 실제 렌더링에서 쉐도우 맵과 관계를 찾아야함. 자기가 뒤에있나 앞에있나.
MVP를 곱하면 다른카메라에서 본 좌표가 나옴. (라이트에서 본 coord)
shadowMVP 좌표계(-1~1)가 안맞기에 반으로 나누고 0.5를 움직임. 범위가 0~1이 되도록 만드는거. -> 이 결과 나온게 shadowBiasMVP 이걸 인포지션과 곱하면
shadowCoord가 나옴. 얘를 shadowMap이랑 비교해서 shadowMap이 더 가까우면, 값이 작으면 그림자가 지는거. visibility를 줄임

shadowcoord는 라이트에서 봤을때, 댑쓰. 이걸 frag로 보냄. 근데 얘는 어그맨티드 백터로 바꾸려고 w로 나눔. 끝을 1로 만들어주려고. 이거 sCoord라고함.

vec3 sCoord = shadowCoord.xyz/shadowCoord.w; 호모를 일반으로 바꾸는 과정
